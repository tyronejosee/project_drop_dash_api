"""Mixins for Utilities App."""

from django.db import models
from django.http import Http404
from django.utils.decorators import method_decorator
from django.core.cache import cache
from django.views.decorators.cache import cache_page
from django.views.decorators.vary import vary_on_headers
from django.utils.text import slugify

from rest_framework.response import Response
from rest_framework import status


class SlugMixin(models.Model):
    """Mixin providing slug functionality for models."""

    slug = models.SlugField(unique=True, blank=True)

    def set_slug(self):
        if hasattr(self, "name") and self.name:
            slug_name = slugify(self.name)[:50]
            if self.slug != slug_name:
                self.slug = slug_name
        elif hasattr(self, "title") and self.title:
            slug_title = slugify(self.title)[:50]
            if self.slug != slug_title:
                self.slug = slug_title
        elif hasattr(self, "word") and self.word:
            slug_word = slugify(self.word)[:50]
            if self.slug != slug_word:
                self.slug = slug_word

    class Meta:
        abstract = True


class ListCacheMixin:
    """Mixin provides caching for the list methods of viewsets."""

    @method_decorator(cache_page(60 * 60 * 2))
    @method_decorator(vary_on_headers("User-Agent"))
    def list(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())

        model_name = queryset.model._meta.verbose_name_plural.lower()
        if not queryset.exists():
            return Response({"message": f"No {model_name} available"})

        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)


class CacheMixin:
    """
    This mixin caches list and retrieve responses using a key generated by get_cache_key.
    The cache is automatically invalidated when an object is created, updated, or deleted.
    """

    cache_timeout = 60 * 60 * 2  # 2 hrs
    # prefix_list = "_list"
    # prefix_detail = "_detail"

    def get_cache_key(self, request, *args, **kwargs):
        """Generate the cache key for the view."""
        raise NotImplementedError(
            "You must override the get_cache_key method in your ViewSet."
        )

    def list(self, request, *args, **kwargs):
        cache_key = self.get_cache_key(request, *args, **kwargs) + "_list"
        data = cache.get(cache_key)
        if not data:
            response = super().list(request, *args, **kwargs)
            data = response.data
            cache.set(cache_key, data, timeout=self.cache_timeout)
            return response
        return Response(data)

    def retrieve(self, request, *args, **kwargs):
        cache_key = self.get_cache_key(request, *args, **kwargs) + "_detail"
        data = cache.get(cache_key)
        if not data:
            response = super().retrieve(request, *args, **kwargs)
            data = response.data
            cache.set(cache_key, data, timeout=self.cache_timeout)
            return response
        return Response(data)

    def perform_create(self, serializer):
        super().perform_create(serializer)
        self.invalidate_cache()

    def perform_update(self, serializer):
        instance = serializer.save()
        self.invalidate_cache(instance)

    def perform_destroy(self, instance):
        super().perform_destroy(instance)
        self.invalidate_cache(instance)

    def invalidate_cache(self, instance=None):
        """
        Method to invalidate the cache.
        Optionally override in the viewset to add extra logic.
        """
        cache_key = self.get_cache_key(self.request) + "_list"
        cache.delete(cache_key)
        if instance:
            cache_key = self.get_cache_key(self.request, pk=instance.pk) + "_detail"
            cache.delete(cache_key)


class LogicalDeleteMixin:
    """Mixin for logical deletion of instances."""

    def destroy(self, request, *args, **kwargs):
        """Deletes the instance logically by marking it as unavailable."""
        try:
            instance = self.get_object()
            instance.is_available = False
            instance.save()
            return Response(status=status.HTTP_204_NO_CONTENT)
        except Http404:
            return Response(
                {"detail": "Resource not found."}, status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {"detail": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class ReadOnlyFieldsMixin:
    """Mixin to make all serializer fields read-only."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        for field in self.fields:
            self.fields[field].read_only = True
